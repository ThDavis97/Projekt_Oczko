\doxysection{C\+:/\+ALL/\+STM32/\+Projekty/\+Oczko\+Gierka/\+Middlewares/\+Third\+\_\+\+Party/\+Free\+RTOS/\+Source/include/atomic.h File Reference}
\label{atomic_8h}\index{C:/ALL/STM32/Projekty/OczkoGierka/Middlewares/Third\_Party/FreeRTOS/Source/include/atomic.h@{C:/ALL/STM32/Projekty/OczkoGierka/Middlewares/Third\_Party/FreeRTOS/Source/include/atomic.h}}


Free\+RTOS atomic operation support.  


{\ttfamily \#include $<$stdint.\+h$>$}\newline
\doxysubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \textbf{ ATOMIC\+\_\+\+ENTER\+\_\+\+CRITICAL}()~\textbf{ port\+ENTER\+\_\+\+CRITICAL}()
\item 
\#define \textbf{ ATOMIC\+\_\+\+EXIT\+\_\+\+CRITICAL}()~\textbf{ port\+EXIT\+\_\+\+CRITICAL}()
\item 
\#define \textbf{ port\+FORCE\+\_\+\+INLINE}
\item 
\#define \textbf{ ATOMIC\+\_\+\+COMPARE\+\_\+\+AND\+\_\+\+SWAP\+\_\+\+SUCCESS}~0x1U
\item 
\#define \textbf{ ATOMIC\+\_\+\+COMPARE\+\_\+\+AND\+\_\+\+SWAP\+\_\+\+FAILURE}~0x0U
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static \textbf{ port\+FORCE\+\_\+\+INLINE} uint32\+\_\+t \textbf{ Atomic\+\_\+\+Compare\+And\+Swap\+\_\+u32} (uint32\+\_\+t volatile $\ast$pul\+Destination, uint32\+\_\+t ul\+Exchange, uint32\+\_\+t ul\+Comparand)
\begin{DoxyCompactList}\small\item\em Performs an atomic compare-\/and-\/swap operation on the specified values. \end{DoxyCompactList}\item 
static \textbf{ port\+FORCE\+\_\+\+INLINE} void $\ast$ \textbf{ Atomic\+\_\+\+Swap\+Pointers\+\_\+p32} (void $\ast$volatile $\ast$ppv\+Destination, void $\ast$pv\+Exchange)
\begin{DoxyCompactList}\small\item\em Atomically sets the address pointed to by $\ast$ppv\+Destination to the value of $\ast$pv\+Exchange. \end{DoxyCompactList}\item 
static \textbf{ port\+FORCE\+\_\+\+INLINE} uint32\+\_\+t \textbf{ Atomic\+\_\+\+Compare\+And\+Swap\+Pointers\+\_\+p32} (void $\ast$volatile $\ast$ppv\+Destination, void $\ast$pv\+Exchange, void $\ast$pv\+Comparand)
\begin{DoxyCompactList}\small\item\em Performs an atomic compare-\/and-\/swap operation on the specified pointer values. \end{DoxyCompactList}\item 
static \textbf{ port\+FORCE\+\_\+\+INLINE} uint32\+\_\+t \textbf{ Atomic\+\_\+\+Add\+\_\+u32} (uint32\+\_\+t volatile $\ast$pul\+Addend, uint32\+\_\+t ul\+Count)
\begin{DoxyCompactList}\small\item\em Atomically adds count to the value of the specified pointer points to. \end{DoxyCompactList}\item 
static \textbf{ port\+FORCE\+\_\+\+INLINE} uint32\+\_\+t \textbf{ Atomic\+\_\+\+Subtract\+\_\+u32} (uint32\+\_\+t volatile $\ast$pul\+Addend, uint32\+\_\+t ul\+Count)
\begin{DoxyCompactList}\small\item\em Atomically subtracts count from the value of the specified pointer pointers to. \end{DoxyCompactList}\item 
static \textbf{ port\+FORCE\+\_\+\+INLINE} uint32\+\_\+t \textbf{ Atomic\+\_\+\+Increment\+\_\+u32} (uint32\+\_\+t volatile $\ast$pul\+Addend)
\begin{DoxyCompactList}\small\item\em Atomically increments the value of the specified pointer points to. \end{DoxyCompactList}\item 
static \textbf{ port\+FORCE\+\_\+\+INLINE} uint32\+\_\+t \textbf{ Atomic\+\_\+\+Decrement\+\_\+u32} (uint32\+\_\+t volatile $\ast$pul\+Addend)
\begin{DoxyCompactList}\small\item\em Atomically decrements the value of the specified pointer points to. \end{DoxyCompactList}\item 
static \textbf{ port\+FORCE\+\_\+\+INLINE} uint32\+\_\+t \textbf{ Atomic\+\_\+\+OR\+\_\+u32} (uint32\+\_\+t volatile $\ast$pul\+Destination, uint32\+\_\+t ul\+Value)
\begin{DoxyCompactList}\small\item\em Performs an atomic OR operation on the specified values. \end{DoxyCompactList}\item 
static \textbf{ port\+FORCE\+\_\+\+INLINE} uint32\+\_\+t \textbf{ Atomic\+\_\+\+AND\+\_\+u32} (uint32\+\_\+t volatile $\ast$pul\+Destination, uint32\+\_\+t ul\+Value)
\begin{DoxyCompactList}\small\item\em Performs an atomic AND operation on the specified values. \end{DoxyCompactList}\item 
static \textbf{ port\+FORCE\+\_\+\+INLINE} uint32\+\_\+t \textbf{ Atomic\+\_\+\+NAND\+\_\+u32} (uint32\+\_\+t volatile $\ast$pul\+Destination, uint32\+\_\+t ul\+Value)
\begin{DoxyCompactList}\small\item\em Performs an atomic NAND operation on the specified values. \end{DoxyCompactList}\item 
static \textbf{ port\+FORCE\+\_\+\+INLINE} uint32\+\_\+t \textbf{ Atomic\+\_\+\+XOR\+\_\+u32} (uint32\+\_\+t volatile $\ast$pul\+Destination, uint32\+\_\+t ul\+Value)
\begin{DoxyCompactList}\small\item\em Performs an atomic XOR operation on the specified values. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Free\+RTOS atomic operation support. 

This file implements atomic functions by disabling interrupts globally. Implementations with architecture specific atomic instructions can be provided under each compiler directory. 

\doxysubsection{Macro Definition Documentation}
\mbox{\label{atomic_8h_ab374919fbdbc585c3436a94f5bad31b6}} 
\index{atomic.h@{atomic.h}!ATOMIC\_COMPARE\_AND\_SWAP\_FAILURE@{ATOMIC\_COMPARE\_AND\_SWAP\_FAILURE}}
\index{ATOMIC\_COMPARE\_AND\_SWAP\_FAILURE@{ATOMIC\_COMPARE\_AND\_SWAP\_FAILURE}!atomic.h@{atomic.h}}
\doxysubsubsection{ATOMIC\_COMPARE\_AND\_SWAP\_FAILURE}
{\footnotesize\ttfamily \#define ATOMIC\+\_\+\+COMPARE\+\_\+\+AND\+\_\+\+SWAP\+\_\+\+FAILURE~0x0U}

Compare and swap failed, did not swap. \mbox{\label{atomic_8h_a2d30f083e50b866caf8822ec31a75969}} 
\index{atomic.h@{atomic.h}!ATOMIC\_COMPARE\_AND\_SWAP\_SUCCESS@{ATOMIC\_COMPARE\_AND\_SWAP\_SUCCESS}}
\index{ATOMIC\_COMPARE\_AND\_SWAP\_SUCCESS@{ATOMIC\_COMPARE\_AND\_SWAP\_SUCCESS}!atomic.h@{atomic.h}}
\doxysubsubsection{ATOMIC\_COMPARE\_AND\_SWAP\_SUCCESS}
{\footnotesize\ttfamily \#define ATOMIC\+\_\+\+COMPARE\+\_\+\+AND\+\_\+\+SWAP\+\_\+\+SUCCESS~0x1U}

Compare and swap succeeded, swapped. \mbox{\label{atomic_8h_a155d89b2444fe81cbc8d051f0fd849c9}} 
\index{atomic.h@{atomic.h}!ATOMIC\_ENTER\_CRITICAL@{ATOMIC\_ENTER\_CRITICAL}}
\index{ATOMIC\_ENTER\_CRITICAL@{ATOMIC\_ENTER\_CRITICAL}!atomic.h@{atomic.h}}
\doxysubsubsection{ATOMIC\_ENTER\_CRITICAL}
{\footnotesize\ttfamily \#define ATOMIC\+\_\+\+ENTER\+\_\+\+CRITICAL(\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})~\textbf{ port\+ENTER\+\_\+\+CRITICAL}()}

\mbox{\label{atomic_8h_a1aab48db50f9e59e44032386aa3eb5b8}} 
\index{atomic.h@{atomic.h}!ATOMIC\_EXIT\_CRITICAL@{ATOMIC\_EXIT\_CRITICAL}}
\index{ATOMIC\_EXIT\_CRITICAL@{ATOMIC\_EXIT\_CRITICAL}!atomic.h@{atomic.h}}
\doxysubsubsection{ATOMIC\_EXIT\_CRITICAL}
{\footnotesize\ttfamily \#define ATOMIC\+\_\+\+EXIT\+\_\+\+CRITICAL(\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})~\textbf{ port\+EXIT\+\_\+\+CRITICAL}()}

\mbox{\label{atomic_8h_aaa356ca7932487d20a42d6839842d308}} 
\index{atomic.h@{atomic.h}!portFORCE\_INLINE@{portFORCE\_INLINE}}
\index{portFORCE\_INLINE@{portFORCE\_INLINE}!atomic.h@{atomic.h}}
\doxysubsubsection{portFORCE\_INLINE}
{\footnotesize\ttfamily \#define port\+FORCE\+\_\+\+INLINE}



\doxysubsection{Function Documentation}
\mbox{\label{atomic_8h_a14d4af36077403e01685fae0cc93ed3d}} 
\index{atomic.h@{atomic.h}!Atomic\_Add\_u32@{Atomic\_Add\_u32}}
\index{Atomic\_Add\_u32@{Atomic\_Add\_u32}!atomic.h@{atomic.h}}
\doxysubsubsection{Atomic\_Add\_u32()}
{\footnotesize\ttfamily static \textbf{ port\+FORCE\+\_\+\+INLINE} uint32\+\_\+t Atomic\+\_\+\+Add\+\_\+u32 (\begin{DoxyParamCaption}\item[{uint32\+\_\+t volatile $\ast$}]{pul\+Addend,  }\item[{uint32\+\_\+t}]{ul\+Count }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Atomically adds count to the value of the specified pointer points to. 

Atomic add


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em pul\+Addend} & Pointer to memory location from where value is to be loaded and written back to. \\
\hline
\mbox{\texttt{ in}}  & {\em ul\+Count} & Value to be added to $\ast$pul\+Addend.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
previous $\ast$pul\+Addend value. 
\end{DoxyReturn}
\mbox{\label{atomic_8h_a9eeea6a0a5bec7c5ad9d3f073d396338}} 
\index{atomic.h@{atomic.h}!Atomic\_AND\_u32@{Atomic\_AND\_u32}}
\index{Atomic\_AND\_u32@{Atomic\_AND\_u32}!atomic.h@{atomic.h}}
\doxysubsubsection{Atomic\_AND\_u32()}
{\footnotesize\ttfamily static \textbf{ port\+FORCE\+\_\+\+INLINE} uint32\+\_\+t Atomic\+\_\+\+AND\+\_\+u32 (\begin{DoxyParamCaption}\item[{uint32\+\_\+t volatile $\ast$}]{pul\+Destination,  }\item[{uint32\+\_\+t}]{ul\+Value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Performs an atomic AND operation on the specified values. 

Atomic AND


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em pul\+Destination} & Pointer to memory location from where value is to be loaded and written back to. \\
\hline
\mbox{\texttt{ in}}  & {\em ul\+Value} & Value to be ANDed with $\ast$pul\+Destination.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The original value of $\ast$pul\+Destination. 
\end{DoxyReturn}
\mbox{\label{atomic_8h_ad0c956772f1d09cea1120c0ed6c4a0df}} 
\index{atomic.h@{atomic.h}!Atomic\_CompareAndSwap\_u32@{Atomic\_CompareAndSwap\_u32}}
\index{Atomic\_CompareAndSwap\_u32@{Atomic\_CompareAndSwap\_u32}!atomic.h@{atomic.h}}
\doxysubsubsection{Atomic\_CompareAndSwap\_u32()}
{\footnotesize\ttfamily static \textbf{ port\+FORCE\+\_\+\+INLINE} uint32\+\_\+t Atomic\+\_\+\+Compare\+And\+Swap\+\_\+u32 (\begin{DoxyParamCaption}\item[{uint32\+\_\+t volatile $\ast$}]{pul\+Destination,  }\item[{uint32\+\_\+t}]{ul\+Exchange,  }\item[{uint32\+\_\+t}]{ul\+Comparand }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Performs an atomic compare-\/and-\/swap operation on the specified values. 

Atomic compare-\/and-\/swap


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em pul\+Destination} & Pointer to memory location from where value is to be loaded and checked. \\
\hline
\mbox{\texttt{ in}}  & {\em ul\+Exchange} & If condition meets, write this value to memory. \\
\hline
\mbox{\texttt{ in}}  & {\em ul\+Comparand} & Swap condition.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Unsigned integer of value 1 or 0. 1 for swapped, 0 for not swapped.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This function only swaps $\ast$pul\+Destination with ul\+Exchange, if previous $\ast$pul\+Destination value equals ul\+Comparand. 
\end{DoxyNote}
\mbox{\label{atomic_8h_a0dfb0b26706475d490792af561a143d5}} 
\index{atomic.h@{atomic.h}!Atomic\_CompareAndSwapPointers\_p32@{Atomic\_CompareAndSwapPointers\_p32}}
\index{Atomic\_CompareAndSwapPointers\_p32@{Atomic\_CompareAndSwapPointers\_p32}!atomic.h@{atomic.h}}
\doxysubsubsection{Atomic\_CompareAndSwapPointers\_p32()}
{\footnotesize\ttfamily static \textbf{ port\+FORCE\+\_\+\+INLINE} uint32\+\_\+t Atomic\+\_\+\+Compare\+And\+Swap\+Pointers\+\_\+p32 (\begin{DoxyParamCaption}\item[{void $\ast$volatile $\ast$}]{ppv\+Destination,  }\item[{void $\ast$}]{pv\+Exchange,  }\item[{void $\ast$}]{pv\+Comparand }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Performs an atomic compare-\/and-\/swap operation on the specified pointer values. 

Atomic compare-\/and-\/swap (pointers)


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em ppv\+Destination} & Pointer to memory location from where a pointer value is to be loaded and checked. \\
\hline
\mbox{\texttt{ in}}  & {\em pv\+Exchange} & If condition meets, write this value to memory. \\
\hline
\mbox{\texttt{ in}}  & {\em pv\+Comparand} & Swap condition.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Unsigned integer of value 1 or 0. 1 for swapped, 0 for not swapped.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This function only swaps $\ast$ppv\+Destination with pv\+Exchange, if previous $\ast$ppv\+Destination value equals pv\+Comparand. 
\end{DoxyNote}
\mbox{\label{atomic_8h_a6bb0ca2c06e0627945b1351ba36d55a7}} 
\index{atomic.h@{atomic.h}!Atomic\_Decrement\_u32@{Atomic\_Decrement\_u32}}
\index{Atomic\_Decrement\_u32@{Atomic\_Decrement\_u32}!atomic.h@{atomic.h}}
\doxysubsubsection{Atomic\_Decrement\_u32()}
{\footnotesize\ttfamily static \textbf{ port\+FORCE\+\_\+\+INLINE} uint32\+\_\+t Atomic\+\_\+\+Decrement\+\_\+u32 (\begin{DoxyParamCaption}\item[{uint32\+\_\+t volatile $\ast$}]{pul\+Addend }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Atomically decrements the value of the specified pointer points to. 

Atomic decrement


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em pul\+Addend} & Pointer to memory location from where value is to be loaded and written back to.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
$\ast$pul\+Addend value before decrement. 
\end{DoxyReturn}
\mbox{\label{atomic_8h_a7ce395cb8553d0fb973f1db2dbac294f}} 
\index{atomic.h@{atomic.h}!Atomic\_Increment\_u32@{Atomic\_Increment\_u32}}
\index{Atomic\_Increment\_u32@{Atomic\_Increment\_u32}!atomic.h@{atomic.h}}
\doxysubsubsection{Atomic\_Increment\_u32()}
{\footnotesize\ttfamily static \textbf{ port\+FORCE\+\_\+\+INLINE} uint32\+\_\+t Atomic\+\_\+\+Increment\+\_\+u32 (\begin{DoxyParamCaption}\item[{uint32\+\_\+t volatile $\ast$}]{pul\+Addend }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Atomically increments the value of the specified pointer points to. 

Atomic increment


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em pul\+Addend} & Pointer to memory location from where value is to be loaded and written back to.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
$\ast$pul\+Addend value before increment. 
\end{DoxyReturn}
\mbox{\label{atomic_8h_a9c13a49fba8a8f1eeca954d6b9dbfac4}} 
\index{atomic.h@{atomic.h}!Atomic\_NAND\_u32@{Atomic\_NAND\_u32}}
\index{Atomic\_NAND\_u32@{Atomic\_NAND\_u32}!atomic.h@{atomic.h}}
\doxysubsubsection{Atomic\_NAND\_u32()}
{\footnotesize\ttfamily static \textbf{ port\+FORCE\+\_\+\+INLINE} uint32\+\_\+t Atomic\+\_\+\+NAND\+\_\+u32 (\begin{DoxyParamCaption}\item[{uint32\+\_\+t volatile $\ast$}]{pul\+Destination,  }\item[{uint32\+\_\+t}]{ul\+Value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Performs an atomic NAND operation on the specified values. 

Atomic NAND


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em pul\+Destination} & Pointer to memory location from where value is to be loaded and written back to. \\
\hline
\mbox{\texttt{ in}}  & {\em ul\+Value} & Value to be NANDed with $\ast$pul\+Destination.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The original value of $\ast$pul\+Destination. 
\end{DoxyReturn}
\mbox{\label{atomic_8h_af1dcc9bcd06047887bc57acb2133b622}} 
\index{atomic.h@{atomic.h}!Atomic\_OR\_u32@{Atomic\_OR\_u32}}
\index{Atomic\_OR\_u32@{Atomic\_OR\_u32}!atomic.h@{atomic.h}}
\doxysubsubsection{Atomic\_OR\_u32()}
{\footnotesize\ttfamily static \textbf{ port\+FORCE\+\_\+\+INLINE} uint32\+\_\+t Atomic\+\_\+\+OR\+\_\+u32 (\begin{DoxyParamCaption}\item[{uint32\+\_\+t volatile $\ast$}]{pul\+Destination,  }\item[{uint32\+\_\+t}]{ul\+Value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Performs an atomic OR operation on the specified values. 

Atomic OR


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em pul\+Destination} & Pointer to memory location from where value is to be loaded and written back to. \\
\hline
\mbox{\texttt{ in}}  & {\em ul\+Value} & Value to be ORed with $\ast$pul\+Destination.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The original value of $\ast$pul\+Destination. 
\end{DoxyReturn}
\mbox{\label{atomic_8h_ac5d1592ac108f14a62aa88be210a205e}} 
\index{atomic.h@{atomic.h}!Atomic\_Subtract\_u32@{Atomic\_Subtract\_u32}}
\index{Atomic\_Subtract\_u32@{Atomic\_Subtract\_u32}!atomic.h@{atomic.h}}
\doxysubsubsection{Atomic\_Subtract\_u32()}
{\footnotesize\ttfamily static \textbf{ port\+FORCE\+\_\+\+INLINE} uint32\+\_\+t Atomic\+\_\+\+Subtract\+\_\+u32 (\begin{DoxyParamCaption}\item[{uint32\+\_\+t volatile $\ast$}]{pul\+Addend,  }\item[{uint32\+\_\+t}]{ul\+Count }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Atomically subtracts count from the value of the specified pointer pointers to. 

Atomic subtract


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em pul\+Addend} & Pointer to memory location from where value is to be loaded and written back to. \\
\hline
\mbox{\texttt{ in}}  & {\em ul\+Count} & Value to be subtract from $\ast$pul\+Addend.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
previous $\ast$pul\+Addend value. 
\end{DoxyReturn}
\mbox{\label{atomic_8h_a98fb15ac72c617dd96a2a4ad55787b86}} 
\index{atomic.h@{atomic.h}!Atomic\_SwapPointers\_p32@{Atomic\_SwapPointers\_p32}}
\index{Atomic\_SwapPointers\_p32@{Atomic\_SwapPointers\_p32}!atomic.h@{atomic.h}}
\doxysubsubsection{Atomic\_SwapPointers\_p32()}
{\footnotesize\ttfamily static \textbf{ port\+FORCE\+\_\+\+INLINE} void $\ast$ Atomic\+\_\+\+Swap\+Pointers\+\_\+p32 (\begin{DoxyParamCaption}\item[{void $\ast$volatile $\ast$}]{ppv\+Destination,  }\item[{void $\ast$}]{pv\+Exchange }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Atomically sets the address pointed to by $\ast$ppv\+Destination to the value of $\ast$pv\+Exchange. 

Atomic swap (pointers)


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em ppv\+Destination} & Pointer to memory location from where a pointer value is to be loaded and written back to. \\
\hline
\mbox{\texttt{ in}}  & {\em pv\+Exchange} & Pointer value to be written to $\ast$ppv\+Destination.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The initial value of $\ast$ppv\+Destination. 
\end{DoxyReturn}
\mbox{\label{atomic_8h_a070776e59f4253dda4ec58b5e2710e81}} 
\index{atomic.h@{atomic.h}!Atomic\_XOR\_u32@{Atomic\_XOR\_u32}}
\index{Atomic\_XOR\_u32@{Atomic\_XOR\_u32}!atomic.h@{atomic.h}}
\doxysubsubsection{Atomic\_XOR\_u32()}
{\footnotesize\ttfamily static \textbf{ port\+FORCE\+\_\+\+INLINE} uint32\+\_\+t Atomic\+\_\+\+XOR\+\_\+u32 (\begin{DoxyParamCaption}\item[{uint32\+\_\+t volatile $\ast$}]{pul\+Destination,  }\item[{uint32\+\_\+t}]{ul\+Value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Performs an atomic XOR operation on the specified values. 

Atomic XOR


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em pul\+Destination} & Pointer to memory location from where value is to be loaded and written back to. \\
\hline
\mbox{\texttt{ in}}  & {\em ul\+Value} & Value to be XORed with $\ast$pul\+Destination.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The original value of $\ast$pul\+Destination. 
\end{DoxyReturn}
